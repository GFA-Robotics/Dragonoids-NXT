#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S4, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     IRSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     rightLift,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftLift,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     backRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     backLeft,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     frontLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     sweeper,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     none,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C1_1,    tilt,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C1_2,    collectingDoor,       tServoStandard)
#pragma config(Servo,  srvo_S4_C1_3,    depositDoor,          tServoStandard)
#pragma config(Servo,  srvo_S4_C1_4,    rightGrabber,         tServoStandard)
#pragma config(Servo,  srvo_S4_C1_5,    leftGrabber,          tServoStandard)
#pragma config(Servo,  srvo_S4_C1_6,    none,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

/* HOW TO CONTROL THE ROBOT USING THE FOLLOWING CODE:

Push left joystick to turn left, right joystick to turn right, and both to move forward.
If one is pushed more than the other, than the robot will go forward and turn slightly.

Gamepad 1 is driving
Gamepad 2 is arm control
*/

// Motor control functions
void stopMotors() {
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	motor[backLeft] = 0;
	motor[backRight] = 0;
}
void applyRightSidePower(int power) {
	motor[frontRight] = power;
	motor[backRight] = power;
}
void applyLeftSidePower(int power) {
	motor[frontLeft] = power;
	motor[backLeft] = power;
}
// Maps controller positions from +-2^7 to -100 to 100
float powerAdjust(int powerLevel) {
	float multiplier = 0.000061 * pow(powerLevel, 2);
	return powerLevel * multiplier * 0.78125; // 0.78125x is the linear function that maps -128 to 127 to -100 to 100
}

const int threshold = 10;
const bool debug = false;

void driver() {
	// Function for the 1st gamepad that controls driving
	// Joystick values are 8 bit signed ints (-127 to 128) of the data type byte
	int forwardAmount = joystick.joy1_y1;
	int turningAmount = joystick.joy1_x2;

	if (abs(forwardAmount) < threshold)
		forwardAmount = 0;
	if (abs(turningAmount) < threshold)
		turningAmount = 0;

	forwardAmount = powerAdjust(forwardAmount);
	turningAmount = powerAdjust(turningAmount);

	int leftSidePower = forwardAmount + turningAmount;
	int rightSidePower = forwardAmount - turningAmount;

	applyLeftSidePower(leftSidePower);
	applyRightSidePower(rightSidePower);

	if (debug) {
		eraseDisplay();
		nxtDisplayString(4, "Right: %d", rightSidePower);
		nxtDisplayString(5, "Left: %d", leftSidePower);
	}
}

int rightLiftPosition = 0;
int leftLiftPosition = 0;

void arm() {
	// Raise the lift when button 8 is pressed and lower it when button 7 is pressed
	const short msLockout = 10;
	if (time1[T1] < msLockout)
		return;
	ClearTimer(T1);

	if (joy2Btn(8) == 1) {
		rightLiftPosition++;
		leftLiftPosition++;
	}
	else if (joy2Btn(7) == 1) {
		rightLiftPosition--;
		leftLiftPosition--;
	}
}

const float kp = 1.0; // Proportional gain (for correcting current error)
const float ki = 0.0; // Integral gain (for measuring past error)
const float kd = 0.0; // Derivative gain (for predicting to future error)

float rightErrorSum = 0;
float rightLastError = 0;
task maintainRightLiftLevel() {
	int currentRightPosition = nMotorEncoder[rightLift];

	int deltaTime = time1[T2];
	float error = rightLiftPosition - currentRightPosition;
	rightErrorSum += (error * deltaTime);
	float dError = (error - rightLastError) / deltaTime;
	motor[rightLift] = kp * error + ki * rightErrorSum + kd * dError;
	rightLastError = error;
	ClearTimer(T2);
}
float leftErrorSum = 0;
float leftLastError = 0;
task maintainLeftLiftLevel() {
	int currentLeftPosition = nMotorEncoder[leftLift];

	int deltaTime = time1[T3];
	float error = leftLiftPosition - currentLeftPosition;
	leftErrorSum += (error * deltaTime);
	float dError = (error - leftLastError) / deltaTime;
	motor[rightLift] = kp * error + ki * leftErrorSum + kd * dError;
	leftLastError = error;
	ClearTimer(T3);
}

task main() {
	/*
	servoChangeRate[flagRaiserExtender] = 5;
	servoChangeRate[blockBlocker] = 8;
	*/
	// Set initial positions of the various servo motors
	servo[tilt] = 0;
	servo[collectingDoor] = 0;
	servo[depositDoor] = 0;
	servo[rightGrabber] = 0;
	servo[leftGrabber] = 0;
	bFloatDuringInactiveMotorPWM = false;
	waitForStart();

	// Reset the lift motor encoders
	nMotorEncoder[rightLift] = 0;
	nMotorEncoder[leftLift] = 0;
	StartTask(maintainRightLiftLevel, kDefaultTaskPriority);
	StartTask(maintainLeftLiftLevel, kDefaultTaskPriority);
	ClearTimer(T1);
	ClearTimer(T2);
	ClearTimer(T3);

	while (true) {
		getJoystickSettings(joystick);
		driver();
		arm();
		// RobotC function for keeping the robot on
		//alive();
	}
}
