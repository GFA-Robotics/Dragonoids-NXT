#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     backRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     backLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     frontLeft,     tmotorTetrix, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

/* HOW TO CONTROL THE ROBOT USING THE FOLLOWING CODE:

Push left joystick to turn left, right joystick to turn right, and both to move forward.
If one is pushed more than the other, than the robot will go forward and turn slightly.

Gamepad 1 is driving
Gamepad 2 is arm control
*/

// Motor control functions
void stopMotors() {
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	motor[backLeft] = 0;
	motor[backRight] = 0;
}
void applyRightSidePower(int power) {
	motor[frontRight] = power;
	motor[backRight] = power;
}
void applyLeftSidePower(int power) {
	motor[frontLeft] = power;
	motor[backLeft] = power;
}
// Maps controller positions from +-2^7 to -100 to 100
float powerAdjust(int powerLevel) {
	float multiplier = 0.000061 * pow(powerLevel, 2);
	return powerLevel * multiplier * 0.78125; // 0.78125x is the linear function that maps -128 to 127 to -100 to 100
}

const int threshold = 10;
const bool debug = false;

void driver() {
	// Function for the 1st gamepad that controls driving
	// Joystick values are 8 bit signed ints (-127 to 128) of the data type byte
	int forwardAmount = joystick.joy1_y1;
	int turningAmount = joystick.joy1_x2;

	if (abs(forwardAmount) < threshold)
		forwardAmount = 0;
	if (abs(turningAmount) < threshold)
		turningAmount = 0;

	forwardAmount = powerAdjust(forwardAmount);
	turningAmount = powerAdjust(turningAmount);

	int leftSidePower = forwardAmount + turningAmount;
	int rightSidePower = forwardAmount - turningAmount;

	applyLeftSidePower(leftSidePower);
	applyRightSidePower(rightSidePower);

	if (debug) {
		eraseDisplay();
		nxtDisplayString(4, "Right: %d", rightSidePower);
		nxtDisplayString(5, "Left: %d", leftSidePower);
	}
}

void arm() {

}

task main() {
	/*
	servoChangeRate[flagRaiserExtender] = 5;
	servoChangeRate[blockBlocker] = 8;

	servo[flagRaiserExtender] = 220;
	servo[wrist] = 90;
	servo[blockBlocker] = 30;

	servo[autoArm] = 145;
	servo[autoBlock] = 200;
	waitForStart();
	//servo[flagRaiserExtender] = 0;
	*/

	while (true) {
		bFloatDuringInactiveMotorPWM = false;
		getJoystickSettings(joystick);
		driver();
		arm();
		// RobotC function for keeping the robot on
		//alive();
	}
}
