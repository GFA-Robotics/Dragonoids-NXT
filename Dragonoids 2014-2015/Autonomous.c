#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S4, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IRSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     rightLift,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     leftLift,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     backRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     backLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     sweeper,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     none,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C1_1,    tilt,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C1_2,    collectingDoor,       tServoStandard)
#pragma config(Servo,  srvo_S4_C1_3,    leftGrabber,          tServoStandard)
#pragma config(Servo,  srvo_S4_C1_4,    rightGrabber,         tServoStandard)
#pragma config(Servo,  srvo_S4_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-gyro.h"

float heading = 0;
const int drivingPower = 40;
const int turnPower = 35;

// Motor control functions
void stopMotors() {
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	motor[backLeft] = 0;
	motor[backRight] = 0;
}
void applyRightSidePower(int power) {
	motor[frontRight] = power;
	motor[backRight] = power;
}
void applyLeftSidePower(int power) {
	motor[frontLeft] = power;
	motor[backLeft] = power;
}
void goForwardPower(int forwardTime, int power) {
	applyRightSidePower(power);
	applyLeftSidePower(power);
	wait1Msec(forwardTime);
	stopMotors();
}
void goBackwardPower(int backwardTime, int power) {
	applyRightSidePower(-power);
	applyLeftSidePower(-power);
	wait1Msec(backwardTime);
	stopMotors();
}
void goForward(int forwardTime) {
	goForwardPower(forwardTime, drivingPower);
}
void goBackward(int backwardTime) {
	goBackwardPower(backwardTime, drivingPower);
}

void turnRight(int desiredRelativeHeading) {
	// Move left side motors forward and right side motors backwards
	float relativeHeadingOffset = heading;
	applyLeftSidePower(turnPower);
	applyRightSidePower(-turnPower);
	while (abs(heading - relativeHeadingOffset) < desiredRelativeHeading) {}
	stopMotors();
}
void turnLeft(int desiredRelativeHeading) {
	// Move right side motors forward and left side motors backwards
	float relativeHeadingOffset = heading;
	applyLeftSidePower(-turnPower);
	applyRightSidePower(turnPower);
	while (abs(heading - relativeHeadingOffset) < desiredRelativeHeading) {}
	stopMotors();
}

// Task for the gyro sensor which sets the global variable
// heading on each update
task gyro() {
	float rotSpeed = 0;
  heading = 0;

  // Reset the timer
  // USES TIMER 4
  // DO NOT USE TIMER 4 ELSEWHERE IN THIS PROGRAM; THINGS WILL EXPLODE AND ROBOT WILL BROKE
  time1[T4] = 0;
  while (true)
  {
    // Wait until 20ms has passed
    while (time1[T4] < 20)
      wait1Msec(1);

    // Reset the timer
    time1[T4] = 0;

    // Read the current rotation speed
    rotSpeed = HTGYROreadRot(gyroSensor);

    // Calculate the new heading by adding the amount of degrees
    // we've turned in the last 20ms
    // If our current rate of rotation is 100 degrees/second,
    // then we will have turned 100 * (20/1000) = 2 degrees since
    // the last time we measured.
    heading += rotSpeed * 0.02;

    // Display our current heading on the screen
    eraseDisplay();
    nxtDisplayCenteredBigTextLine(4, "%3.2f", heading);
	}
}
task main() {
	// Set some initial servo positions here

	// Calibrate the gyro, make sure you hold the sensor still
  HTGYROstartCal(gyroSensor);
  nxtDisplayTextLine(4, "Gyro calibration completed");
  // Spawn the gyro heading task
  StartTask(gyro, kHighPriority);
  // Calculate the dift per second value
  float initialHeading = heading;
  wait1Msec(1000);
  float driftPerSecond = heading - initialHeading;
  ClearTimer(T2); // T2 used for measuring the elapsed time since drift was calculated

  nxtDisplayTextLine(6, "Waiting for start...");
  PlaySound(soundUpwardTones);
  // Open the hopper for a ball to be placed in

  // Initialize servos
	servo[tilt] = 110;
	servo[collectingDoor] = 255;
	// Retracted
	servo[leftGrabber] = 255;
	servo[rightGrabber] = 0;
 	waitForStart();
	//wait1Msec(5000);
  eraseDisplay();

	// Advance towards the medium goal that's straight ahead
	const int rampMilliseconds = 2800;
	//goForwardPower(rampMilliseconds, 20);
	const int downRampPower = 20;
	applyRightSidePower(downRampPower + 8);
	applyLeftSidePower(downRampPower);
	wait1Msec(rampMilliseconds);
	stopMotors();
	// Turn around
	turnLeft(46);
	// Fully extend the tube grabber
	const int servoMeasuringThreshold = 10;
	servo[leftGrabber] = 0;
	servo[rightGrabber] = 255;
	// Wait for them to reach that position
	while(ServoValue[leftGrabber] > servoMeasuringThreshold && ServoValue[rightGrabber] < (255 - servoMeasuringThreshold)) {}
	// Go forward until reaching the tube (maybe use the ultrasonic sensor instead of a magic number?)
	const int tubeMilliseconds = 1500;
	goBackward(tubeMilliseconds);
	// Lower the tube grabbers
	servo[leftGrabber] = 128;
	servo[rightGrabber] = 128;
	while(ServoValue[rightGrabber] > 128 + servoMeasuringThreshold && ServoValue[leftGrabber] < (128 - servoMeasuringThreshold)) {}
	// Place a ball in this tube (?)
	// Move tube to scoring zone
	const int turnDegrees = 4;
	turnRight(turnDegrees);
	// Backwards to scoring zone
	const int moveToScoringZoneTime = 3700;
	const float movingDesiredHeading = heading - (time100[T2] / 10) * driftPerSecond;
	const int correctivePower = 10;
	ClearTimer(T1);
	while (time1[T1] < moveToScoringZoneTime) {
		// Only run this loop every 100 milliseconds (10 Hz)
		if (time1[T1] % 100 != 0)
			continue;
		float correctedHeading = heading - (time100[T2] / 10) * driftPerSecond;
		if (correctedHeading - movingDesiredHeading > 2) {
			// Correct towards the left
			applyLeftSidePower(drivingPower);
			applyRightSidePower(drivingPower + 2 * correctivePower);
		}
		else if (correctedHeading - movingDesiredHeading > 1) {
			// Correct towards the left
			applyLeftSidePower(drivingPower);
			applyRightSidePower(drivingPower + correctivePower);
		}
		else if (correctedHeading - movingDesiredHeading < 2) {
			// Correct towards the left
			applyLeftSidePower(drivingPower + 2 * correctivePower);
			applyRightSidePower(drivingPower);
		}
		else if (correctedHeading - movingDesiredHeading < 1) {
			// Correct towards the right
			applyLeftSidePower(drivingPower + correctivePower);
			applyRightSidePower(drivingPower);
		}
		else {
			applyLeftSidePower(drivingPower);
			applyRightSidePower(drivingPower);
		}
	}
	stopMotors();
	// Turn towards the edge of the scoring zone
	turnLeft(6);
	goForward(800);
	// Turn around
	turnLeft(50);
	// Back up a bit
	goBackward(500);
	// Score a ball
	/*const int upPower = 55;
	const int downPower = -30;
	motor[rightLift] = upPower;
	motor[leftLift] = upPower;
	wait1Msec(5200);
	motor[rightLift] = 0;
	motor[leftLift] = 0;
	servo[tilt] = 0;*/

	// Open the grabbers
	servo[leftGrabber] = 0;
	servo[rightGrabber] = 255;
	// Wait for them to reach that position
	while(ServoValue[leftGrabber] > servoMeasuringThreshold && ServoValue[rightGrabber] < (255 - servoMeasuringThreshold)) {}
	// Go forward a bit
	goForward(700);
	// Retract the grabber things (will be opened at beginning of tele-op)
	servo[leftGrabber] = 255;
	servo[rightGrabber] = 0;
	while(ServoValue[leftGrabber] < (255 - servoMeasuringThreshold) && ServoValue[rightGrabber] > servoMeasuringThreshold) {}
	// Measure the IR direction
	int IRDir = HTIRS2readACDir(IRSeeker);
	switch (IRDir) {
		case 5:
			goForward(1400);
			turnLeft(25);
			goForward(550);
			turnLeft(12);
			break;
		case 3:
			goForward(1600);
			turnLeft(25);
			goForward(400);
			turnLeft(15);
			break;
		case 4:
			// TEST THIS CASE
			goForward(2000);
			turnRight(14);
			goBackward(500);
			turnLeft(15);
			break;
		default:
			turnLeft(1);
			turnRight(1);
			break;
	}

	PlaySound(soundDownwardTones);
	wait1Msec(1000);
}
