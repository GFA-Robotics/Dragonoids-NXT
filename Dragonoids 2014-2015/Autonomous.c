#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S4, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     gyroSensor,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     IRSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     rightLift,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftLift,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     backRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     backLeft,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     frontLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     sweeper,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     none,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C1_1,    tilt,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C1_2,    collectingDoor,       tServoStandard)
#pragma config(Servo,  srvo_S4_C1_3,    depositDoor,          tServoStandard)
#pragma config(Servo,  srvo_S4_C1_4,    rightGrabber,         tServoStandard)
#pragma config(Servo,  srvo_S4_C1_5,    leftGrabber,          tServoStandard)
#pragma config(Servo,  srvo_S4_C1_6,    none,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-gyro.h"

float heading = 0;

// Motor control functions
void stopMotors() {
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	motor[backLeft] = 0;
	motor[backRight] = 0;
}
void applyRightSidePower(int power) {
	motor[frontRight] = power;
	motor[backRight] = power;
}
void applyLeftSidePower(int power) {
	motor[frontLeft] = power;
	motor[backLeft] = power;
}

// Task for the gyro sensor which sets the global variable
// heading on each update
task gyro() {
	float rotSpeed = 0;
  heading = 0;

  // Reset the timer
  // USES TIMER 4
  // DO NOT USE TIMER 4 ELSEWHERE IN THIS PROGRAM
  time1[T4] = 0;
  while (true)
  {
    // Wait until 20ms has passed
    while (time1[T4] < 20)
      wait1Msec(1);

    // Reset the timer
    time1[T4] = 0;

    // Read the current rotation speed
    rotSpeed = HTGYROreadRot(gyroSensor);

    // Calculate the new heading by adding the amount of degrees
    // we've turned in the last 20ms
    // If our current rate of rotation is 100 degrees/second,
    // then we will have turned 100 * (20/1000) = 2 degrees since
    // the last time we measured.
    heading += rotSpeed * 0.02;

    // Display our current heading on the screen
    eraseDisplay();
    nxtDisplayCenteredBigTextLine(4, "%3.2f", heading);
	}
}
task main() {
	// Set some initial servo positions here

	// Calibrate the gyro, make sure you hold the sensor still
  HTGYROstartCal(gyroSensor);
  nxtDisplayTextLine(4, "Gyro calibration completed");

  nxtDisplayTextLine(6, "Waiting for start...");
  PlaySound(soundUpwardTones);
  // Open the hopper for a ball to be placed in


  //wait1Msec(5000);
 	waitForStart();
  eraseDisplay();
  // Spawn the gyro heading task
  StartTask(gyro, kHighPriority);
	const int power = 30;
	const int turnPower = 20;

	// Advance towards the medium goal that's straight ahead
	const int advanceMilliseconds = 2500;
	applyRightSidePower(power);
	applyLeftSidePower(power);
	wait1Msec(advanceMilliseconds);
	// Lift the arm


}
