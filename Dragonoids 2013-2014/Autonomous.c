#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     motorMux,       sensorNone)
#pragma config(Sensor, S2,     IRSeeker,       sensorI2CCustom)
#pragma config(Sensor, S3,     colorSensor,    sensorCOLORFULL)
#pragma config(Sensor, S4,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motor1,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motor2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motor3,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motor4,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     unlabeledMotor1, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     unlabeledMotor2, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     unlabeledMotor3, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     unlabeledMotor4, tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "drivers/hitechnic-irseeker-v2.h"
#include "JoystickDriver.c"
int offset = 0;
/*

motor 1 ---------- motor 2
|                        |
|                        |
motor 3 ---------- motor 4

Sensor port 1 = Multiplexer for motors
Sensor port 2 = IR Sensor for dectecting the IR beacon
Sensor port 3 = NXT Color Sensor for sensing the Red/Blue line
Sensor port 4 = Gyro Sensor for detecting robot rotation for turns

*/
// Motor control functions
void forwardMotors(int power) {
    motor[motor1] = power;
    motor[motor2] = power;
	motor[motor3] = power;
	motor[motor4] = power;
}
void stopMotors() {
    forwardMotors(0);
}
// Autonomous flow functions
void turn(int degrees, bool clockwise = true, bool inPlace = false) {
	if (degrees < 0 && !clockwise)
		degrees *= -1;

	const int powerInTurn = 50;
	if (clockwise) {
		motor[motor1] = powerInTurn;
		motor[motor3] = powerInTurn;
	}
	else {
		motor[motor2] = powerInTurn;
		motor[motor4] = powerInTurn;
	}
	// Rotation is measured in degrees per second
	const int updatesPerSecond = 100; // Can't be greater than 300
	float degreesTurned = 0;
	while (true) {
		float degreesPerSecond = (float)(SensorValue[gyroSensor] - offset);
		degreesPerSecond /= updatesPerSecond; // Degrees per update
		degreesTurned += degreesPerSecond;
		if ((int)degreesTurned > degrees)
			break;
		wait1Msec(1000 / updatesPerSecond);
	}
	stopMotors();
}
bool continueUntilIR() {
    ClearTimer(T1);
    const int maxRunTime = 20000;
    int runTime = 0;
    int IRDir;
    forwardMotors(50);
    while (runTime < maxRunTime) {
        IRDir = HTIRS2readACDir(IRSeeker);
        if (IRDir == 0) {
            stopMotors();
            return true;
        }
        if (IRDir < 6) {
            // Somethings wrong, the beacon is behind the robot
            stopMotors();
            return false;
        }
        runTime = time1[T1];
    }
}
void moveToLine(string color) {
    ClearTimer(T1);
    const int maxRunTime = 8000;
    const int maxFailures = 5000; // This will most likely be changed in the future
    
    int failures = 0;
    int runTime = 0;
    string reportedColor;
    forwardMotors(40);
    
    while (runTime < maxRunTime && failures < maxFailures) {
        reportedColor = SensorValue[colorSensor];
        if (reportedColor == "???") {
            failures++;
            continue;
        }
        if (reportedColor == color) {
            // Found the line
            stopMotors();
            return;
        }
        runTime = time1[T1];
    }
}
void placeBlock() {
    // To be finished when arm is finalized
    return;
}

task main() {
	string colorString;
	// Wait 1 second for user input
	eraseDisplay();
	nxtDisplayBigTextLine(4, "Press button for Red");
	wait1Msec(1000);
	if (nNxtButtonPressed == 3) {
		// Pressed orange button
		// Red side
		colorString = "Red";
	}
	else {
		// Not pressed
		// Blue side
		colorString = "Blue";
	}
	// Output color value to the display
	eraseDisplay();
	nxtDisplayBigTextLine(4, "%s Alliance");

	// Calibrate the gyro sensor
	const int calibrationIter = 10;
	for (int i = 0; i < calibrationIter; i++) {
		offset += SensorValue(gyroSensor);
	}
	offset /= calibrationIter;

	waitForStart();
	eraseDisplay();
	turn(45, false);
    if (!continueUntilIR()) {
        return 1;
    }
    turn(90);
    moveToLine();
    placeBlock();
}