#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     motorMux,       sensorNone)
#pragma config(Sensor, S2,     ultrasonic,     sensorSONAR)
#pragma config(Sensor, S3,     gyroSensor,     sensorAnalogInactive)
#pragma config(Sensor, S4,     IRSeeker,       sensorI2CCustom)
#pragma config(Motor,  motorA,          blockMotor1,   tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          blockMotor2,   tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     rearRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     rearLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     armMotor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     flagMotor,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    flagRaiserExtender,   tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    blockBlocker,         tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    autoArm,              tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    autoBlock,            tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-gyro.h"
#include "JoystickDriver.c"

float heading = 0;

// Motor control functions
void stopMotors() {
	motor[frontLeft] = 0;
  motor[frontRight] = 0;
	motor[rearLeft] = 0;
	motor[rearRight] = 0;
}
void leftSidePower(int power) {
	motor[frontLeft] = power;
	motor[rearLeft] = power;
}
void rightSidePower(int power) {
	motor[frontRight] = power;
	motor[rearRight] = power;
}


// Task for the gyro sensor which sets the global variable
// heading on each update
task gyro() {
	float rotSpeed = 0;
  heading = 0;

  // Reset the timer
  // USES TIMER 4
  // DO NOT USE TIMER 4 ELSEWHERE IN THIS PROGRAM
  time1[T4] = 0;
  while (true)
  {
    // Wait until 20ms has passed
    while (time1[T4] < 20)
      wait1Msec(1);

    // Reset the timer
    time1[T4] = 0;

    // Read the current rotation speed
    rotSpeed = HTGYROreadRot(gyroSensor);

    // Calculate the new heading by adding the amount of degrees
    // we've turned in the last 20ms
    // If our current rate of rotation is 100 degrees/second,
    // then we will have turned 100 * (20/1000) = 2 degrees since
    // the last time we measured.
    heading += rotSpeed * 0.02;

    // Display our current heading on the screen
    eraseDisplay();
    nxtDisplayCenteredBigTextLine(4, "%3.2f", heading);
	}
}
task main() {
	servoChangeRate[flagRaiserExtender] = 5;
	servoChangeRate[autoBlock] = 5;
	servoChangeRate[autoArm] = 3;

	servo[flagRaiserExtender] = 220;
	servo[wrist] = 200;
	servo[blockBlocker] = 30;

	servo[autoArm] = 40;
	servo[autoBlock] = 200;

	// Calibrate the gyro, make sure you hold the sensor still
  HTGYROstartCal(gyroSensor);
  nxtDisplayTextLine(4, "Gyro calibration completed");

  nxtDisplayTextLine(6, "Waiting for start...");
  PlaySound(soundUpwardTones);

  //wait1Msec(5000);
 	waitForStart();
  eraseDisplay();
  // Spawn the gyro heading task
  StartTask(gyro, kHighPriority);
	const int power = 30;
	const int turnPower = 20;

	// -45 degrees
  /*while (heading > -15) {
  	rightSidePower(power);
	}*/
	// Forward in case of first IR beacon position
	int IRDir = HTIRS2readACDir(IRSeeker);
	int initialMoveTime = 0;
	if (IRDir == 0) {
		initialMoveTime = 0;
	}
	if (IRDir == 3 || IRDir == 4) {
		initialMoveTime = 1000;
	}

	rightSidePower(power);
	leftSidePower(power);
	wait1Msec(initialMoveTime);
	stopMotors();

	//IRDir = HTIRS2readACDir(IRSeeker);
	//if (IRDir == 5) {
	//	rightSidePower(-power);
	//	leftSidePower(-power);
	//	wait1Msec(300);
	//	stopMotors();
	//}

	// Forward until 5 IR signal
	ClearTimer(T1);
	while (true) {
		IRDir = HTIRS2readACDir(IRSeeker);
		if (IRDir == -1) {
			// Stop the autonomous program if the IR seeker isn't connected
			stopMotors();
			PlaySound(soundException);
			return;
		}
		// If sensor is ahead of us
		if (IRDir < 5) {
			rightSidePower(power);
			leftSidePower(power);
		}
		// If sensor is behind us for some reason
		if (IRDir > 5) {
			rightSidePower(-power);
			leftSidePower(-power);
		}
		// Centered IR beacon
		if (IRDir == 5) {
			stopMotors();
			break;
		}
	}
	long timeToFindIR = time1[T1];

	// Place in bin
	const int autoArmMoveTo = 250;
	const int autoBlockMoveTo = 1;
	servo[autoArm] = autoArmMoveTo;
	while (ServoValue[autoArm] < autoArmMoveTo) {
		wait1Msec(20);
	}
	servo[autoBlock] = 1;
	while (ServoValue[autoBlock] > autoBlockMoveTo) {
		eraseDisplay();
		nxtDisplayCenteredTextLine(5, "BlockMoveTo: %d", ServoValue[autoBlock]);
		wait1Msec(20);
	}

	// Retract arm
	servo[autoBlock] = 200;
	while (ServoValue[autoBlock] < 200) {
		wait1Msec(20);
	}
	servo[autoArm] = 1;
	while (ServoValue[autoArm] > 1) {
		wait1Msec(20);
	}
	// Drive forward same time it took to get to beacon
	rightSidePower(-power);
	leftSidePower(-power);
	wait1Msec(timeToFindIR + initialMoveTime);
	stopMotors();

	wait1Msec(1000);
	// -90 degrees
	while (heading < 40) {
  	rightSidePower(-turnPower);
  	leftSidePower(turnPower);
	}
	stopMotors();
	wait1Msec(1000);
	// Forward a bit to line up with ramp
	rightSidePower(power);
	leftSidePower(power);
	wait1Msec(1650);
	stopMotors();
 	// +90 degrees
	wait1Msec(1000);
	while (heading > 10) {
  	rightSidePower(turnPower + 30);
  	leftSidePower(-(turnPower));
	}
	stopMotors();
	wait1Msec(1000);
 	// Backward time it takes to get to ramp
	rightSidePower(power);
	leftSidePower(power);
	wait1Msec(3500);
	stopMotors();

	PlaySound(soundDownwardTones);

  /* Game plan
  -45 degrees
  Forward until 5 IR signal
  +90 degrees
  Place in bin
  +90 degrees
  Retract arm
  Drive forward same time it took to get to beacon
  -90 degrees
  Forward a bit
  -90 degrees
  Forward time it takes to get to ramp
  */
}
